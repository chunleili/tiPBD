import numpy as np
import scipy
import scipy.sparse as sparse
import os, sys
from time import perf_counter
from matplotlib import pyplot as plt
import pyamg
from pyamg.gallery import poisson


sys.path.append(os.getcwd())


def test_amg_vs_jacobi():
    # ---------------------- data generated by pyamg poisson --------------------- #
    A = poisson((10, 10), format="csr")
    b = np.random.rand(A.shape[0])
    print(f"A: {A.shape}, b: {b.shape}")

    # generate R by pyamg
    global ml
    ml = pyamg.classical.ruge_stuben_solver(A, max_levels=2)  # construct the multigrid hierarchy
    print("ml bulit")
    P = ml.levels[0].P
    R = ml.levels[0].R

    # ------------------------------- test solvers ------------------------------- #

    use_AMG = True
    use_pyamg = True
    use_pyamgmy = True

    # pyamg
    if use_pyamg:
        r_norm_list_pyamg = []
        t = perf_counter()
        x0 = np.zeros_like(b)
        x_pyamg = solve_pyamg(ml, b, r_norm_list_pyamg)
        t_pyamg = perf_counter() - t
        t = perf_counter()

    # my pyamg reproduction
    if use_pyamgmy:
        r_norm_list_pyamgmy = []
        t = perf_counter()
        x0 = np.zeros_like(b)
        x_pyamg = solve_pyamg_my(A, b, x0, R, P, ml, r_norm_list_pyamgmy)
        t_pyamg = perf_counter() - t
        t = perf_counter()

    # ------------------------------- plot ------------------------------- #
    fig, axs = plt.subplots(1, 2, figsize=(10, 4))

    if use_pyamg:
        plot_r_norm_list(r_norm_list_pyamg, axs[0, 0], "pyamg")
    if use_pyamgmy:
        plot_r_norm_list(r_norm_list_pyamgmy, axs[0, 1], "pyamgmy")
    plt.tight_layout()
    plt.show()


def solve_pyamg(ml, b, r_norm_list=[]):
    x = ml.solve(b, tol=1e-3, residuals=r_norm_list, maxiter=1)
    return x


def solve_pyamg_my(A, b, x0, R, P, ml, r_norm_list=[]):
    max_levels = 2

    tol = 1e-3
    residuals = r_norm_list
    maxiter = 1

    levels = []
    levels.append(ml.levels[0])
    levels.append(ml.levels[1])

    x = np.zeros_like(b)

    # Scale tol by normb
    # Don't scale tol earlier. The accel routine should also scale tol
    normb = np.linalg.norm(b)
    if normb == 0.0:
        normb = 1.0  # set so that we have an absolute tolerance

    # Start cycling (no acceleration)
    normr = np.linalg.norm(b - A @ x)
    if residuals is not None:
        residuals[:] = [normr]  # initial residual

    b = np.ravel(b)
    x = np.ravel(x)

    it = 0

    while True:  # it <= maxiter and normr >= tol:
        if len(levels) == 1:
            # hierarchy has only 1 level
            x = ml.coarse_solver(A, b)
        else:
            __solve(levels, 0, x, b, cycle="V", cycles_per_level=1)

        it += 1

        normr = np.linalg.norm(b - A @ x)
        if residuals is not None:
            residuals.append(normr)

        if normr < tol * normb:
            return x

        if it == maxiter:
            return x


def __solve(levels, lvl, x, b, cycle, cycles_per_level=1):
    A = levels[lvl].A

    levels[lvl].presmoother(A, x, b)

    residual = b - A @ x

    coarse_b = levels[lvl].R @ residual
    coarse_x = np.zeros_like(coarse_b)

    if lvl == len(levels) - 2:
        coarse_x[:] = ml.coarse_solver(A, b)


def coarse_solver(A2, r2):
    global ml
    return ml.coarse_solver(A2, r2)


def plot_r_norm_list(data, ax, title):
    x = np.arange(len(data))
    ax.plot(x, data, "-o")
    ax.set_title(title)
    ax.set_yscale("log")
    ax.set_xlabel("iteration")
    ax.set_ylabel("residual")


if __name__ == "__main__":
    test_amg_vs_jacobi()
